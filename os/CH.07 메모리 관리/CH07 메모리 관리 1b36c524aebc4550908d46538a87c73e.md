# CH07.메모리 관리

메모리는 주소를 통해 접근하는 저장장치

- 주소(address)란?

    : 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자로 구성

## 1. 주소 바인딩

- 논리적 주소(logical address) or 가상 주소(virtual address) 란?

    : 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성 되는데 이를 말함

CPU는 이와 같이 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다. 

- 물리적 주소(physical address)

    : 물리적 메모리에 실제로 올라가는 위치를 말한다.

보통 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.

⇒ 이렇게 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 **주소바인딩** 이라고 한다.

- 주소 바인딩 방식 (프로그램이 적재되는 물리적메모리의 주소가 결정되는 시기에 따라 분류)

1) 컴파일 타임 바인딩(compile time binding) 방식

: 물리적 메모리 주소가 프로그램을 컴파일할 때 결정됨

컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 결정한다. 

프로그램이 절대주소로 적재된다는 뜻에서 **주소 바인딩 방식** or  **절대코드(absolute code)를 생성하는 바인딩 방식** 이라고도 말한다.

- 단점

    : 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶다면 컴파일을 다시 하는 수고가 필요. 즉, 비현실적이고 현대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는 기법

2) 로드 타임 바인딩(load time binding) 방식

: 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식 

로더(loader)의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다

- 로더란?

    : 사용자 프로그램을 메모리에 적재시키는 프로그램을 말한다.

이 바인딩 방식은 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식이다.

3) 실행시간 바인딩(execution time binding 또는 run time binding) 방식

: 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식이다. CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검해야 한다. 

또한 다른 방식들과 달리 실행시간 바인딩 방식이 가능하기 위해서는 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함해 MMU(Memory Management Unit : 메모리 관리 유닛)라는 하드웨어적인 지원이 뒷받침되어야 한다.

- MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

- 기본적인 방식으로 주소 변환을 수행하는 MMU 기법(MMU scheme)

CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다. 이때 기준 레지스터는 재배치 레지스터(relocatation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.

프로그램의 주소공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다. 따라서 그 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다. 

![0](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled.png)

> 재배치 레지스터에는 현재 CPU에서 수행중인 프로세스의 물리적 메모리 시작 주소가 저장되어 있다. CPU가 논리적 주소 123번지에 있는 내용을 요청할 경우 재배치 레지스터에 저장된 23000이라는 값에 이 주소를 더해 물리적 메모리 23123번지에 있는 내용을 참조하게 된다. 그러면 물리적 메모리 23123번지에서 CPU가 요청한 정보를 찾게 된다.

> 논리적 주소 123번지는 물리적 메모리의 시작 위치인 재배치 레지스터값으로부터 요청된 위치가 얼마나 떨어져 있는지를 나타내는 일종의 오프셋(offset)개념으로 생각할 수 있다.

 프로세스는 자기 자신만의 고유한 주소 공간을 가지고 있으므로 동일한 주소값이라 하더라도 각 프로세스마다 서로 다른 내용을 담고 있게 된다. 따라서 CPU가 논리적 주소 100번지를 참조한다고 했을 때 현재 CPU가 수행되고 있는 프로세스가 무엇인지에 따라 이 100번지가 가리키는 내용은 상이해진다.

흔히 사용하는 다중 프로그래밍 환경에서 MMU 방식을 사용할 경우 CPU가 요청한 논리적 주소값+재배치 레지스터 안에있는 값 = 결과가 해당 프로세스의 주소 공간을 벗어나는 경우가 발생할 수 있다. 이렇게 되면 메모리 보안(memory protection)이 이루어지지 않아 시스템에 치명적인 결과를 초래할 수도 있다. 

⇒ 운영체제는 이를 방지하기 위해 한계 레지스터(limit register)를 사용한다.

- 한계 레지스터?

    : 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용되며, 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고 있다. 

![1](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled1.png)

## 2. 메모리 관리와 관련된 용어

### 1) 동적로딩(dynamic loading)

: 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나이다. 

- 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 메모리를 좀 더 효율적으로 사용하기 위해 해당 부분이 불릴 때 그 부분만을 메모리에 적재하는 방식을 사용한다.

실제로 프로그램의 코드 중 상당 부분은 오류 처리루틴과 같이 아주 특별한 경우에 가끔씩 사용되는 방어용 코드 → 메모리의 낭비가 초래됨

⇒ 이를 막아 메모리를 효율적으로 사용 !!

- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며 운영체제가 라이브러리를 통해 지원할 수도 있다.
- 라이브러리가 실행시점에 연결된다. 실행파일에 라이브러리 코드가 포함되지 않는다.
- 실행파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둔다.
- 라이브러리 호출시 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는지 살펴보고 그럴 경우 그 주소의 메모리 위치에서 직접 참조하며, 그렇지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행하게 된다.

### 2) 동적연결

: 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법이다.

- 연결(linking)이란?

    : 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일(library file)들을 묶어 하나의 실행파일을 생성하는 과정을 말한다.

↔ 정적연결(static linking)

: 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성된다. 따라서 실행파일의 크기가 상대적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로 물리적 메모리가 낭비되는 단점이 있다. 

이는 비효율적이라 동적연결. 

→ 메모리에 쓸데없이 똑같은게 너무 많이 올라가더라 ! 

많이 쓰는 라이브러리는 메모리에 하나만 올리자로 ...

### 3) 중첩(overlays)

: 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법을 말한다. (동적로딩과 개념적으로 유사)

- 엄밀히는, 초창기의 컴퓨터 시스템에서 물리적 메모리의 크기 제약으로 인해 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없을 때, 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법을 뜻한다.
- 운영체제의 지원 없이 프로그래머에 의해 구현되어야 했다 해서 수작업 중첩(manual overlays)이라고도 부른다. 구현하는 것 상당히 복잡함
- 동적 로딩 vs 중첩
    - 중첩 : 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택
    - 동적로딩 : 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도

### 4) 스와핑(swapping)

: 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것을 말한다.

- 스왑 영역(swap area)란?

    : 백킹스토어(backing store)라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다.

    - 프로세스가 수행중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 짧은 저장공간이다.
    - 다수의 사용자 프로세스를 담을 수 있을 만큼 충분히 큰 저장공간이어야 하고 어느 정도의 접근 속도가 보장되어야 한다.

⚠️주의할 점 !

스와핑이라는 개념이 프로세스가 종료되어 그 주소 공간을 디스크로 내쫓는 것이 아니라, 특정한 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미한다는 것

- 일어나는 작업의 방향에 따라
- 스왑 인(swap in) : 디스크에서 메모리로 올리는 작업
- 스왑 아웃(swap out) : 메모리에서 디스크로 내리는 작업

 

스와핑이 일어나는 과정

1) 스와퍼(swapper)라고 불리는 중기 스케쥴러(medium-term scheduler)에 의해 스왑아웃시킬 프로세스를 선정한다. 

2) 스왑 아웃 대상으로 선정된 프로세스에 대해서는 현재 메모리에 올라가 있는 주소 공간의 내용을 통째로 디스크 스왑 영역에 스왑 아웃시키게 된다.

- 스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것이다. 즉 다중 프로그래밍의 정도(degree of muliprogramming)를 조절 할 수 있다
- 너무 많은 프로그램이 메모리에 동시에 올라오게 되면 프로세스당 할당되는 메모리의 양이 지나치케 적어져 시스템 전체의 성능이 크게 떨어진다. 그래서 몇몇 프로그램을 통째로 디스크의 스왑 영역으로 내쫓음으로써 메모리에 남아 있는 프로그램들에게 적절한 메모리 공간을 보장한다.
- 앞에서 본 컴파인 타임 바인딩 방식 & 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때에는 원래 존재하던 메모리 위치로 다시 올라가야 한다. but, 실행시간 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.
- 

![2](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled2.png)

보통 디스크 내의 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장되기 때문에, 스와핑에 소요되는 시간은 디스크의 탐색시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간이 대부분을 차지한다.

- 탐색시간(seek time)이란 ?

    read/write 헤드를 데이터가 저장되어 있는 트랙 위치로 이동시키는데 소요되는 시간

- 회전지연시간(rotational latency)이란?

    read/write 헤드를 데이터가 위치하는 트랙으로 이동시킨 순간부터 원하는 섹터에 헤드가 다다를 때까지 소요되는 시간

- 전송시간(transfer time)이란?

    read/write 헤드가 찾은 데이터를 실제로 디스크로부터 사용자의 버퍼로 보내지는데 소요되는 시간

![3](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled3.png)

> 현재 물리적 메모리에 워드프로세서 프로그램이 올라가 있다고 하자. 이때 사용자가 웹 브라우저 프로그램을 사용하고자 하는데 이를 실행하기 위한 메모리 공간이 충분하지 않을 경우, 운영체제는 메모리 내에 이미 존재하는 워드프로세서에 할당된 메모리 공간을 통째로 빼앗아 디스크의 스왑영역으로 스왑 아웃시키고 그렇게 해서 생긴 여유 공간에 웹 브라우저 프로그램의 주소 공간을 스왑 인시킬 수 있게 된다.

## 3. 물리적 메모리의 할당 방식

물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉘어 사용된다.

**운영체제 상주 영역**은 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, 운영체제 커널이 이곳에 위치하게 된다.

**사용자 프로세스 영역**은 물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행된다. 

<요약>

사용자 프로세스 영역의 관리 방법 → 프로세스를 메모리에 올리는 방식에 따라

- 연속할당(contiguous allocation) 방식

    : 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식이다. 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.

    물리적 메모리를 고정된 크기의 분할로 미리 나누어 놓는가 아닌가에 따라

    - 고정분할(fixed partition allocation) 방식

        : 물리적 메모리를 고정된 크기의 분할로 미리 나누어두는 방식

    - 가변분할(variable partition allocation) 방식

        : 분할을 미리 나누어놓지 않은 채 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식 

- 불연속할당(noncontiguous allocation) 방식

    : 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식이다. 

    - 페이징(paging) 기법 : 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 것
    - 세그먼테이션(segmentation) 기법 : 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재하는 것
    - 페이지드 세그먼테이션(paged segmentation) 기법 : 세그먼트 하나를 다수의 페이지로 구성하는 것

### 1-1) 연속할당 방식

: 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에서 연속적으로 적재하는 방식이다.

### 1-2) 고정분할 방식

: 물리적 메모리를 주어진 개수만큼의 영구적인 분할(partition)로 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 한다. 이때 분할의 크기는 모두 동일하게 할 수도 있고 서로 다르게 할 수도 있다. → 프로그램 수가 고정되어 있어 가변분할 방식에 비해 융통성 떨어짐

- 외부조각과 내부조각이 발생할 수 있다.

![4](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled4.png)

- 외부조각(external fragmentation)이란?

    : 프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간

- 내부조각 (internal fragmentation)

    : 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간을 뜻한다. 특정 프로그램에 이미 배당된 공간으로 볼 수 있으므로 내부조각에 수용할 수 있는 충분히 작은 크기의 프로그램이 있다 해도 공간을 활용할 수 없어 메모리가 낭비된다.

### 1-3) 가변분할 방식

: 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식을 말한다. 

프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법을 필요로 한다. 

- 분할의 크기를 프로그램의 크기보다 일부러 크게 할당하지 않기 때문에 내부 조각은 발생하지 않는다.
- but, 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부조각이 발생할 가능성이 있다.

동적 메모리 할당 문제(dynamic storage-allocation problem) : 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지 결정하는 문제이다. 

- 가용 공간이란?

    : 사용되지 않은 메모리 공간으로서 메모리 내의 여러 곳에 산발적으로 존재할 수 있다.

    운영체제는 이미 사용중인 메모리 공간과 사용하고 있지 않은 가용 공간에 대한 정보를 각각 유지하고 있다. 

동적 메모리 할당 문제를 해결하는 대표적인 방법

1) 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당하는 최초적합(first-fit) 방법 

- 메모리에 존재하는 가용 공간을 차례대로 살펴보면서 가용 공간이 프로그램 크기보다 작으면 건너뛰고, 그렇지 않은 가용 공간이 최초로 발견되면 그 공간에 프로그램을 올린다.
- 시간적인 측면에서 효율적

2) 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당하는 최적적합(best-fit) 방법 

- 가용 공간들의 리스트가 크기순으로 정렬되어 있지 않은 경우에 모든 가용 공간 리스트를 탐색해야 하므로 시간적 오버헤드가 발생하고 다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점.
- but, 공간적인 측면에서 효율적

3) 가용 공간 중에서 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 최악적합(worst-fit) 방법

- 모든 가용 공간 리스트를 탐색해야 하므로 시간적 오버헤드가 발생
- 상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제점

실제 시스템에서 실함한 결과 ! 

최초적합 & 최적저갑 방식 > 최악적합 방식 (속도와 공간 이용률 측면) 

가변분할 방식에서 발생하는 외부조각 문제를 해결하기 위한 방법 : 컴팩션(compaction)

- 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법이다.
- 현재 수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시켜야 하므로 비용이 매우 많이 드는 작업이다.
- 효율적인 컴팩션을 수행하는 방법? 이론적으로 매우 복잡한 문제
- 효율적인 메모리 공간의 사용을 위해 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야 하므로 프로그램의 실행 도중에 프로세스의 주소가 동적으로 바뀔 수 있는 실행시간 바인딩 방식이 지원되는 환경에서만 수행될 수 있다.

### 2) 불연속할당 기법

: 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법을 말한다. 

- 페이징(paging) 기법 : 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 것
- 세그먼테이션(segmentation) 기법 : 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재하는 것
- 페이지드 세그먼테이션(paged segmentation) 기법 : 세그먼트 하나를 다수의 페이지로 구성하는 것

## 4. 페이징 기법

: 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식을 말한다.

- 각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요 x, 일부는 백킹스토어에, 일부는 물리적 메모리에 혼재시키는 것이 가능하다.
- 물리적 메모리를 페이지와 동일한 크기의 프레임(frame)으로 미리 나누어둔다.
- 메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로, 메모리를 같은 크기로 미리 분할해두더라도 빈 프레임이 있으면 어떤 위치이든 사용될 수 있기 때문이다.
- 동적 메모리 할당 문제가 발생하지 않는다.

![5](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled5.png)

> 주소 변환 절차가 다소 복잡하다. 하나의 프로세스라 하더라도 페이지 단위로 물리적 메모리에 올리는 위치가 상이하므로, 논리적 주소를 물리적 주소로 변환하는 작업이 페이지 단위로 이루어져야 하기 때문이다.

- 특정 프로세스의 몇 번째 페이지가 물리적 메모리의 몇 번째 프레임에 들어 있다는 페이지별 주소 변환 정보로써 주소 변환을 위한 페이지 테이블(page table)을 가지며, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.
- 프로세스의 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위로 나누어지기 때문에 빈 공간은 어느 곳이든 활용 할 수 있다. → 외부조각 문제 발생X
- BUT, 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 프로세스의 주소 공간 중 마지막에 위치한 페이지에서는 내부조각이 발생할 가능성이 있다.

### 1) 주소 변환 기법

: CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환(address translation)에 사용한다. 

- 페이지 번호 : 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스로 사용되고, 행당 인덱스의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소(base address), 즉 시작 위치가 저장된다.
- 따라서, 특정 프로세스의 p번째 페이지가 위치한 물리적 메모리의 시작 위치를 알고 싶다면 해당 프로세스의 페이지 테이블에서 p번째 항목을 찾아보면 된다.
- 페이지 오프셋 : 하나의 페이지 내에서의 변위(displacement)를 알려준다.
- 따라서, 기준 주소값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 얻을 수 있다.

![6](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled6.png)

### 2) 페이지 테이블의 구현

페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료구조로, 물리적 메모리에 위치하게 된다. 현재 CPU에서 실행중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용하는데 아래와 같다.

1. 페이지 테이블 기준 레지스터(page-table base register)

    : 메모리 내에서의 페이지 테이블의 시작 위치를 가리킨다.

2. 페이지 테이블 길이 레지스터(page-table length register)

    : 페이지 테이블의 크기를 보관한다.

- 페이징 기법에서의 메모리 접근 연산은 주소 변환을 위해 페이지 테이블에 접근 하는 것과, 변환된 주소에서 실제 데이터에 접근하는 것,  이렇게 두 번의 메모리 접근을 필요로 한다.

→ 메모리에 한 번 접근하기 위해서 매번 메모리에 두 번 접근해야하는 오버헤드가 뒤따른다.

- 이러한 페이지 테이블 접근 오버헤드를 줄이고 메모리의 접근 속도를 향상시키기 위해 TLB(Translation Look-aside Buffer)라고 불리는 고속의 주소 변환용 하드웨어 캐시가 사용 되기도 한다.
- 메모리에 비해 TLB로 사용 되는 하드웨어 가격 비쌈💸 → 빈번히 참조되는 페이지에 대한 주소 변환 정보만을 담음
- 요청된 페이지 번호가 TLB에 존재한다면 대응하는 물리적 메모리의 프레임 번호를 바로 얻을 수 있지만, 존재하지 않는 경우에는 메인 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아내야 한다.
- 주소 변환 정보는 프로세스별로 다 다르기 때문에 문맥교환 시 이전 프로세스의 주소 변환 정보를 가지고 있던 TLB 내용은 모두 지워버려야 한다.

한편 페이지 테이블과 TLB에 저장되어 있는 정보는 그 구조가 조금 다르다. 

- 페이지 테이블에는 하나의 프로세스를 구성하는 모든 페이지에 한 정보가 페이지 번호에 따라 순차적으로 들어 있음 . 반면 TLB는 모든 페이지에 대한 주소 변환 정보를 가지고 있지 않아 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어야 한다.

TLB를 통한 주소 변환을 위해서는 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하기 위해 TLB의 모든 항목(entry)을 다 찾아봐야 하는 오버헤드가 발생한다.

- 이 오버헤드를 줄이기 위해 병렬탐색이 가능한 연관 레지스터(associative register)를 사용한다.
- 병렬탐색 기능이란?

    : TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능

    ![7](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/22.jpg)

연관 레지스터를 사용할 때 평균적인 메모리 접근시간(Effective Access Time : EAT)

- 메모리에 접근하는 시간을 1
- 연관 레지스터에 접근하는 시간을 ε

→ ε은 1보다 충분히 작은 값이 될 것이다. 

- 요청된 페이지에 대한 주소 변환 정보가 연관 레지스터에 존재할 확률을 α라고 하면 평균적인 메모리 접근시간 EAT는 다음과 같다.

![8](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled7.png)

( 1+ε )α항 : 요청된 페이지의 주소 변환 정보가 TLB에 존재하는 경우를 뜻한다. 

- 이 경우 TLB로부터 직접 물리적 메모리 주소를 얻는 데 ε시간이 소요되고, 실제 원하는 데이터에 접근하기 위해 한 번의 메모리 접근이 필요하므로 1+ε 의 시간이 소요된다.
- 여기에 TLB에서 찾아지는 비율인 α를 곱하면 첫 번째 항을 얻을 수 있다.

( 2+ε )( 1-α )는 요청된 페이지의 주소 변환 정보가 TLB에 존재하지 않는 경우를 뜻한다.

- 요청된 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하는 시간 ε이 먼저 소요되고, 그런 다음 페이지 테이블에 접근하는 시간과 실제 원하는 데이터에 접근하는 시간 등 두 번의 메모리 접근이 필요하게 된다.
- 따라서 2+ε의 시간이 소요되며, 여기에 TLB에서 찾지 못하는 비율인 1-α를 곱하여 두 번째 항인 ( 2+ε )( 1-α )가 얻어지게 된다,

⇒ TLB가 사용되는 시스템에서의 평균 메모리 접근시간은 위의 식을 정리하면 2 + ε - α가 된다. 

### 3) 계층적 페이징

![9](CH07%20메모리%20관리%201b36c524aebc4550908d46538a87c73e/Untitled8.png)

### 4) 역페이지 테이블


### 5) 공유 페이지

## 5. 세그먼테이션

## 6. 페이지드 세그먼테이션