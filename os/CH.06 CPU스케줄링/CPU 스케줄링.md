# 6장 CPU 스케줄링

* CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙 처리장치
* 프로그램이 시작되어 메모리에 올라가면 프로그램 카운터라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있게 됨. CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행함.
* CPU는 일반적으로 한 시스템 내에 하나씩밖에 없으므로 여러 프로그램이 동시에 수행되는 시분할 환경에서 매우 효율적으로 관리되어야 함.

## 프로그램 실행과 관련된 몇가지 기계어 명령
* CPU 내에서 수행되는 명령
	* Add 명령 : CPU내의 레지스터에 있는 두 값을 더해 레지스터에 저장. CPU 내에서만 수행되므로 명령의 수행 속도가 매우 빠름 
* 메모리 접근을 필요로 하는 명령
	* Load/Store 명령 : 메모리에 있는 데이터를 CPU로 / CPU에서 계산된 결과값을 메모리에 저장. 메모리에 접근하는 명령은 비록 CPU 내에서 수행되는 명령보다는 시간이 오래 소요되지만 비교적 짧은 시간에 수행할 수 있는 명령에 해당됨. 또한 CPU 내에서 일어나는 명령이나 메모리를 접근하는 명령은 사용자 프로그램이 직접 실행할 수 있는 일반명령에 해당.
* 입출력을 동반하는 명령
	* 키보드로부터 입력, 컴퓨터에서 처리된 결과를 화면에 출력, 디스크에서 파일 데이터를 읽어오거나 디스크에 파일 형태로 저장하는 것. CPU나 메모리 접근 명령에 비해 오랜 시간이 걸림. 또한 모든 입출력 명령을 특권명령으로 규정해 운영체제를 통해 서비스를 대행하도록 하고 있음.

![](2021-03-04-17-35-12.png)

사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O 작업의 반복으로 구성됨.
* CPU 버스트 : 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계. 프로그램이 I/O를 한 번 수행한 후 다음 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업.
* I/O 버스트 : I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계. I/O 작업이 요청된 후 완료되어 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업.

### 위와 같은 기준에서 프로세스를 나눌수 있음
* CPU 바운드 프로세스: I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스를 말함. 프로세스 수행의 상당 시간을 입출력 작업없이 CPU 작업에 소모하는 계산 위주의 프로그램에 해당. 소수의 긴 CPU 버스트로 구성됨
* I/O 바운드 프로세스: I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스를 말함. 주로 사용자로부터 인터랙션(interaction)을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램이 해당됨. 짧은 CPU 버스트를 많이 가지고 있음.

CPU 스케줄링은 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요한 것.

![](2021-03-04-17-35-57.png)

컴퓨터 시스템 내에서 수행되는 프로세스들의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지고 극히 일부분만 긴 CPU 버스트를 가짐. 즉 I/O 작업을 수행한는 프로세스들이 많다. 이러한 대화형 작업은 사용자와 인터랙션을 해가며 프로그램을 수행시킴. 즉 사용자에게서 입력을 받아 CPU 연산을 수행하고 그 결과를 다시 출력하는 작업을 수행. 따라서 빠른 응답이 중요!! (CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요 자세한 이유는 뒤에서~)

## 1. CPU 스케줄러
CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드. 프로세스가 CPU를 할당받고 기계어 명령을 수행하다가 타이머 인터럽트가 발생하면 CPU 스케줄러가 호출됨. 그러면 CPU 스케줄러는 준비 큐에서 CPU를 기다리는 프로세스 중 하나를 선택해 CPU를 할당하게 됨. 이 밖에도 CPU 스케줄링이 필요한 경우들이 몇가지 있음.
스케줄링 방식에 따라
* 비선점형(nonpreemptive) : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법. ex) 실행상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄(blocked)상태로 바뀌는 경우, CPU에서 실행 상태에 있는 프로세스가 종료되는 경우
*  선점형(preemptive) : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법. ex) 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우, I/O 요청으로 봉쇄 상태에 있던 프로세스가 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비상태로 바뀌는 경우(이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아, 인터럽트 처리 후 직전에 수행되던 프로세스에게 CPU를 다시 할당하는 것이 아니라 문맥교환을 통해 I/O가 완료된 프로세스에게 CPU를 할당하는 경우가 해당됨)

## 2. 디스패처
CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요. 이와같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 디스패처(dispatcher)라고 함.
* 디스패처: 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행.

새로운 프로세스의 문맥을 복원시킨 후에는 시스템의 상태를 사용자모드로 전환해 사용자 프로그램에게 CPU의 제어권을 넘기게 됨. 사용자 프로그램은 PC로부터 현재 수행할 주소를 찾게 됨.

* 디스패치 지연시간: 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간 (대부분은 문맥교환 오버헤드에 해당됨)

## 3. 스케줄링의 성능 평가
스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용되는데 이 지표들은 크게 시스템 관점의 지표와 사용자 관점의 지표로 나누어 볼 수 있음.
* 시스템 관점: CPU 이용률, 처리량
	* CPU 이용률(CPU utilization)은 전체 시간 중에서 CPU가 일을 한 시간의 비율을 나타냄. CPU는 대부분의 시스템에 하나만 존재하는 고비용의 자원이므로 CPU의 이용률은 시스템 전체의 성능과 밀접하게 관련됨. 따라서 CPU가 일을 하지 않고 휴면(idle) 상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표가 됨.
	* 처리량(throughput)은 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스의 개수)를 나타냄. 즉 CPU의 서비스를 원하는 프로세스 중 몇 개가 원하는 만큼의 CPU를 사용하고 이번 CPU 버스트를 끝내어 준비 큐를 떠났는지 측정하는 것이 처리량의 개념. 여러 프로세스가 CPU를 기다리고 있는 상황에서 주어진 시간에 더 많은 프로세스들이 CPU 작업을 완료하기 위해서는 CPU버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리. 
* 사용자 관점: 소요시간, 대기시간, 응답시간 등 기다린 시간과 관련된 지표들이 있음.
	* 소요시간(turnaround time)은 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간, 즉 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합. 해당 CPU 버스트가 완료될 때까지 걸리는 시간으로 프로그램이 시작해서 종료하는 데까지 걸리는 시간이 아님! (에를들어 CPU르 사용하다가 I/O 연산을 위해 CPU를 자진 반납했다면 CPU를 사용하기 위해 준비 큐에 들어왔을 때부터 CPU를 자진 반납하기까지 걸린 시간이 소요시간이 됨.)
	* 대기시간(waiting time)은 CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합. 시분할 시스템에서는 일반적으로 타이머를 사용해서 CPU를 연속적으로 사용할수 있는 시간을 제한함. 따라서 한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러번 발생할 수 있음. 이때 대기시간이란 이번 CPU 버스트가 끝나기까지 준비 큐에서 기다린 시간의 합을 뜻하게 됨.
	* 응답시간(response time)은 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간을 뜻함. 타이머 인터럽트가 빈번히 발생할수록 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 짧아지므로 처음 CPU를 얻기까지 걸리는 시간은 줄어들게 되어 응답시간이 향상됨. 대화형 시스템에 적합한 성능 척도.

## 4. 스케줄링 알고리즘

### 1) 선입선출 스케줄링
* 선입선출(First-Come First-Served FCFS) 스케줄링은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말함.

* 일상생활에서도 흔히 볼 수 있듯이 먼저 온 요청을 먼저 처리하기 때문에 합리적인 것처럼 보임.

* 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라짐.

![](2021-03-04-17-36-36.png)

![](2021-03-04-17-36-50.png)

* 대기시간: P1 = 0, P2 = 12, P3 = 15

* 평균 대기시간: (0+12+15)/3 = 9

![](2021-03-04-17-37-04.png)

* 대기시간: P1 = 6, P2 = 0, P3 = 3

* 평균 대기시간: (6+0+3)/3 = 3

* 전자의 경우처럼 CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 convoy effect라고 하며 FCFS 스케줄링의 대표적인 단점에 해당.

### 2) 최단작업 우선 스케줄링
* 최단작업 우선(Shortest-Job First SJF) 스케줄링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식.

* CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비 큐를 빠져나가게 되면 전체적인 대기시간이 줄어들게 됨.

* SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘

* 비선점형(nonpreemptive) 방식과 선점형(preemptive) 방식이 있음

* 비선점형: CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식을 말함.

* 선점형: 준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했다 하더라도, CPU 버스트가 더 짧은 프로세스가 도착했을 경우 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식. 현재 실행중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 프로세스가 도착할 경우 CPU를 빼앗음. 따라서 SRTF(Shortest Remaining Time First)라고도 함.

* 프로세스들이 준비 큐에 도착하는 시간이 불규칙하면 선점형 방식이 평균 대기시간을 최소화하는 최적의 알고리즘이 되고 그렇지 않으면 큰 차이 없음. 일반적인 시분할 환경에서는 선점형이 유리.

* SJF

  ![](2021-03-04-17-37-21.png)

  

  ![](2021-03-04-17-37-33.png)

* 평균 대기시간: (0+12+6+14) / 4 = 8

* SRTF

  ![](2021-03-04-17-37-44.png)

* 평균 대기시간: (18+2+0+4) / 4 = 6

* 그러나 SJF 스케줄링 기법의 구현에서 현실적으로 어려운 부분은 프로세스의 CPU 버스트 시간을 미리 알 수 없다는 점. 그래서 예측을 통해 CPU 버스트 시간을 구함.

* CPU 버스트 시간의 예측은 과거의 CPU 버스트 시간을 통해 이루어짐

* (n+1)번째 CPU 버스트의 예측시간 
  $$
  T_{n+1}=at_n+(1-a)T_n
  $$
  
* tn과 Tn은 각각 n번째 실제 CPU 버스트 시간과 n번째 CPU 버스트의 예측시간을 뜻하며, a는 0과 1사이의 상수로 두 요소를 어느 정도 씩 반영할지 조절하는 매개변수.

* a=0 이면 고정된 값이 예측값으로 계속 사용이 되고 a=1이면 바로 전에 사용한 CPU 버스트 시간을 예측값으로 사용하게 됨.

* 즉 과거의 CPU 버스트 시간들을 통해 미래의 CPU 버스트 시간을 예측하게 되고 최근의 CPU 버스트 시간일수록 오래전의 CPU 버스트 시간에 비해 가중치를 높이는 방식

* $$
  T_{n+1}=at_n+(1-a)at_{n-1}+...+(1-a)^jat_{n-j}+...
  $$

* SJF 알고리즘이 평균 대기시간을 최소화하는 알고리즘이기는 하지만 시스템에서 평균을 줄이는 것이 항상 좋은 방법이라고는 할 수 없음. CPU가 버스트가 짧은 프로세스에게만 CPU를 할당할 경우 CPU 버스트가 긴 프로세스는 무한정 기다려야 하기 때문.

* 이러한 현상을 기아현상(Starvation)이라고 하고 극복하는 방법은 뒤에서 설명.

### 3) 우선순위 스케줄링
* 우선순위 스케줄링(Priority Scheduling)이란 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말함.
* 우선순위는 우선순위값(Prioriry Number)을 통해 표시하고 우선순위값이 작을수록 높은 우선순위를 가짐.
* 우선순위를 결정하는 방식에는 CPU 버스트 시간을 우선순위값을 정의하면 SJF와 동일하게 되고 시스템과 관련된 중요한 작업을 수행하는 프로세스의 우선순위를 높게 부여할수도 있음.
* 비선점형과 선점형 방식으로 구현 가능
* 비선점형은 일단 CPU를 얻었으면 자진 반납하기 전까지 선점하지 않음.
* 선점형은 현재 CPU에서 수행 중인 프로세스보다 우선순위가 높은 프로세스가 도착하여 CPU를 선점하는 방식.
* 문제점은 기아 현상이 발생할 수 있음. (우선순위가 높은 프로세스가 계속해서 도착하면 우선순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다려야 함)
* 이러한 문제점을 해결하기 위해서 노화(Aging) 기법을 사용.
* 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 하는 방법.

### 4) 라운드 로빈 스케줄링
* 시분할 시스템 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식
* 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며, 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 있는 다른 프로세스에게 CPU를 할당.
* 이 때 각 프로세스마다 한 번에 CPU를 연속적으로 사용할 수 있는 최대시간을 할당시간 (time quantum)
* 할당시간이 너무 길면 FCFS와 같은 결과, 너무 짧으면 너무 빈번히 교체되어 문맥교환의 오버헤드가 커짐. 
  * 따라서 일반적으로 수십 밀리초로 설정.
* 라운드 로빈 스케줄링은 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적
  * ex) n개의 프로세스가 준비 큐에 있고 할당시간이 q라고 할 때, 모든 프로세스는 (n-1)q시간 이내에 적어도 한번은 CPU를 할당받을 수 있음. 
  * 대화형 프로세스의 빠른 응답시간을 보장할 수 있는 장점이 있음.
* 각 프로세스의 대기시간이 그 프로세스의 CPU 버스트 시간에 비례
  * ex)

  ![](2021-03-04-20-06-18.png)
  * p1,p2,p3가 순서대로 도착했다고 가정
  * 할당시간이 10인 라운드 로빈 스케줄링
  ![](2021-03-04-20-34-57.png)
  * 할당시간이 만료되어 CPU를 회수하는 방법으로는 타이머 인터럽트를 사용
  * 기본적인 목적은 CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을수 있게 하는 동시에 CPU 버스트 시간이 긴 프로세스가 불이익을 당하지 않도록 하는 것.
  * SJF 스케줄링의 경우 평균 대기시간 측면에서는 가장 우수한 결과를 보장하지만 CPU 버스트 시간이 짧은 프로세스에게만 유리함. 일부의 희상을 통해 전체의 성능을 높임. 효율성 > 형평성
    * SJF에서 CPU 버스트 시간이 긴 프로세스는 무한정 기다리게 될 수도 있음. 
  * 라운드 로빈 스케줄링은 공정한 스케줄링 방식. 자신이 CPU를 쓰고자 하는 양이 적으면 소요시간(turn around time)이 짧아지고 CPU를 쓰고자 하는 양이 많으면 소요시간도 비례해서 길어짐.
    * 할당시간을 너무 짧게 설정하면 문맥교환의 오버헤드가 증가해 전체 시스템의 성능을 저하시킬 수 있음.
    * P1 CPU 버스트 시간 10  
    * 할당시간 10 : 문맥교환이 없음
    * 할당시간 5 : 문맥교환이 1회
    * 할당시간 1 : 문맥교환이 9회
    
   ![](2021-03-04-20-41-41.png)

   * FCFS VS 라운드 로빈 스케줄링 (대기시간, 응답시간, 소요시간)
   * CPU 버스트 시간이 10인 프로세스 10개가 모두 시각 0에 도착
   * FCFS
     * P1의 대기시간 0, P2는 10 ... P10은 90 응답시간도 동일한 값을 가짐
     * 평균 대기시간과 응답시간은 45
     * 소요시간은 P1:10, P2:20 ... P10:100 
     * 평균 소요시간은 55
     * 적어도 하나씩은 처리가 완료된 프로세스가 발생하여 평균 대기시간이나 평균 소요시간 측면에서 좋은 결과를 얻을 수 있음. 그러나 프로세스 간 대기시간이나 소요시간의 편차가 매우 크며, 평균 응답시간이 지나치게 길어지는 문제점이 있음.
   * 라운드 로빈 스케줄링
     * 할당시간을 극단적으로 짧게 설정하면 10개의 프로세스가 100이라는 시간 안에 거의 동시에 자신의 CPU 버스트를 끝마치게 됨.
     * 대기시간이나 처리시간의 편차가 크지 않음. 그러나 중간 산출물 없이 모든 프로세스가 마지막이 되어서야 함께 끝마치므로 평균 대기시간과 평균 소요시간이 각각 90, 100에 이르게 되어 FCFS보다 비효율적
   * 즉 FCFS에서는 CPU를 먼저 쓰고 나가는 프로세스의 소요시간 및 대기시간이 짧아지는 반면, 라운드 로빈 스케줄링에서는 CPU를 조금씩 같이 쓰고 거의 동시에 끝나게 되어 소요시간 및 대기시간이 가장 오래 기다린 프로세스에 맞춰지게 됨.
   * 동일한 CPU 버스트 시간을 가지는 프로세스들에 라운드 로빈 스케줄링을 적용할 경우 평균 대기시간 및 평균 소요시간이 더 길어짐 그러나 평균 응답시간은 더 짧아짐.
   * 일반적인 시스템에서는 프로세스의 CPU 버스트 시간이 균일하지 않고 각자 다른 CPU 버스트 및 I/O 버스트를 가지는 경우가 대부분. 이러한 경우 라운드 로빈 스케줄링을 적용하면 CPU 버스트 시간에 비례해서 소요시간이 증가하게 되므로 매우 합리적이라 할 수 있음.

### 5) 멀티레벨 큐
* 멀티레벨 큐란 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법.
* 즉 프로세스들이 CPU를 기다리기 위해 한 줄로 서는 것이 아니라 여러 줄로 서는 것.
* CPU가 하나밖에 없으므로 어떤 줄에 서 있는 프로세스를 우선적으로 스케줄링할 것인가 + 프로세스가 도착했을 때 어느 줄에 세워야 할지 결정하는 메커니즘도 필요.
* 일반적으로 성격이 다른 프로세스들을 별도로 관리, 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비 큐를 별도로 두게 됨.
* ex) 빠른 응답을 필요로 하는 대화형 작업과 그렇지 않은 작업을 별도의 큐에 줄 세우도록 하고, 대화형 작업이 기다리고 있다면 이들에게 우선적으로 CPU를 할당하고 대화형 작업이 없을 때 나머지 작업에게 CPU를 할당.
  
  ![](2021-03-04-21-16-24.png)
* 대화형 작업을 담기 위한 전위 큐, 계산 위주의 작업을 담기 위한 후위 큐로 분할해서 운영
* 전위 큐는 응답시간을 짧게 하기 위해 라운드 로빈 스케줄링 사용. 후위 큐는 응답시간이 큰 의미를 갖지 않기 때문에 FCFS 사용.
* 멀티레벨 큐에서는 큐 자체에 대한 스케줄링이 필요.
* 여러 개의 준비 큐에 대해서 어느 큐에 먼저 CPU를 할당할 것인지 결정하는 스케줄링이 필요.
* 큐에 대한 스케줄링으로 가장 쉽게 생각할 수 있는 방식은 고정 우선순위 방식.
  * 큐에 고정적인 우선순위를 부여해서 순위가 높은 큐를 먼저 서비스하고 낮은 큐는 높은 큐가 비어 있을 때에만 서비스하게 됨.
* 타임 슬라이스 방식
  * 큐에 대한 기아 현상을 해소할 수 있는 방식
  * 각 큐에 CPU 시간을 적절한 비율로 할당
  * ex) 전위 큐에는 80%, 후위 큐에는 20%
  
### 6) 멀티레벨 피드백 큐
* 멀티레벨 피드백 큐는 CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능하다는 점이 다름.
* 멀티레벨 피드백 큐는 프로세스들의 다양한 성격을 반영해 구현할 수 있음.
* ex) 우선순위 스케줄링에서 기아 현상을 해결하기 위해 등장했던 노화 기법(aging)을 멀티레벨 피드백 큐 방식으로 구현할 수 있음. 우선순위가 낮은 큐에서 오래 기다렸으면 우선순위가 높은 큐로 승격.
* 멀티레벨 피드백 큐를 정의하는 요소들로는 큐의 수, 각 큐의 스케줄링 알고리즘, 프로세스를 상위 큐로 승격시키는 기준, 프로세스를 하위 큐로 강등시키는 기준, 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준 등.

  ![](2021-03-04-21-28-56.png)

* 그림에서 상위에 있는 큐일수록 우선순위가 높으며, 상위 2개의 큐는 각각 할당시간이 5와 10인 라운드 로빈 스케줄링을 사용. 세 번째 큐는 FCFS 스케줄링 기법을 사용.
* 프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐에 줄을 선다. CPU 사용시간이 짧은 대화형 프로세스들은 우선순위가 가장 높은 큐에서 빨리 서비스받고 작업을 완료할 수 있음
* CPU 버스트 시간이 길면 5만큼의 시간 동안 CPU를 사용하고도 작업을 완료할 수 없기 때문에 할당시간이 10인 하위 큐로 내려가서 줄을 선다. 하위 큐에서도 작업이 완료되지 않으면 최하위 큐로 이동. 큐에 대한 스케줄링은 최상위 큐가 우선적으로 CPU를 배당받고, 상위 큐가 비었을때만 하위 큐에 있는 프로세스들이 CPU를 할당받을 수 있게 됨.
* 프로세스의 CPU 작업시간을 다단계로 분류함으로써 작업시간이 짧은 프로세스일수록 더욱 빠른 서비스가 가능하도록 하고, 작업시간이 긴 프로세스에 대해서는 문맥교환 없이 CPU 작업에만 열중할 수 있는 FCFS 방식을 채택할 수 있게 함.

### 7) 다중처리기 스케줄링
* CPU가 여러 개인 시스템을 다중처리기 시스템이라고 부른다.
* CPU 스케줄링이 CPU가 하나인 시스템에서보다 더욱 복잡한 문제가 있음.
* 프로세스를 준비 큐에 한 줄로 세워서 각 CPU가 알아서 다음 프로세스를 꺼내어가도록 할 수 있음.
  * ex) 은행창구에서 번호표
* 그러나 특정 CPU에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더욱 복잡해짐.
  * ex) 미용실 헤어디자이너
* 이러한 경우는 각 CPU 별로 줄 세우기를 할수도 있음.
* 여러 줄로 줄 세우기를 하는 경우 일부 CPU에 작업이 편중되는 현상이 발생할 수 있음.
* 각 CPU별 부하가 적절히 분산되도록 하는 부하균형(load balancing) 메커니즘이 필요로 함.
* 대칭형과 비대칭형으로 나눌 수 있음.
* 대칭형 다중처리기 (symmetric multi-processing): 각 CPU가 각자 알아서 스케줄링을 결정하는 방식. 각 처리기의 스케줄러가 준비큐를 검사하여 자신이 실행할 프로세스를 선정함. 서로 다른 프로세스가 공동의 자료에 접근 및 갱신해야하므로 스케줄러는 매우 신중하게 짜여져야 함. 서로 다른 2개의 처리기가 같은 프로세스를 선택해선 안됨.
* 비대칭형 다중처리기 (asymmetric multiprogramming): 하나의 CPU(마스터 서버 역할을 함)가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 거기에 따라 움직이는 방식을 말함. 다른 처리기들은 사용자 코드만 수행함. 한 처리기만 시스템 자료구조에 접근하여 처리기 간의 커널 내 자료들을 공유할 필요가 없음. 따라서 상호배재 등의 문제도 단순해 짐. 하지만 하나의 서버의 로드가 심하여 처리기 간 부하가 불균등하고 서버에 문제가 생기면 시스템 전체로 그 문제가 확산될 수 있음.

### 8) 실시간 스케줄링
* 시분할 시스템에서는 작업의 처리가 빠를수록 좋지만 특정 시간 이내에 처리하지 못했다고 해서 심각한 상황이 발생하는 것은 아님. 즉 데드라인이 존재하지 않음.
* 실시간 시스템(real-time system)에서는 각 작업마다 주엊니 데드라인이 있어 정해진 데드라인 안에 반드시 작업을 처리해야 한다.
* 경성 실시간 시스템(hard real-time system)은 미사일 발사, 원자로 제어 등 시간을 정확히 지켜야 하는 시스템을 말함. 데드라인안에 반드시 작업이 완료되도록 스케줄링을 해야함.
* 연성 실시간 시스템(soft real-time system)은 멀티미디어 스트리밍 시스템이 대표적인 예. 데드라인을 지키지 못했다고 해서 위험한 상황이 발생하지는 않음.
* 따라서 실시간 스케줄링에서는 빠른 서비스도 중요하지만 데드라인을 지키는 서비스가 더욱 중요함. 따라서 EDF(Earlist Deadline First) 스케줄링을 널리 사용. 데드라인이 얼마 남지 않은 요청을 먼저 처리.

## 5. 스케줄링 알고리즘의 평가
* 성능을 평가하는 방법으로는 큐잉모델, 시뮬레이션, 구현 및 실측 방식이 있음.
* 큐잉모델은 주로 이론가들이 수행하는 방식으로, 확률분포를 통해 프로세스들의 도착률과 CPU의 처리율을 입력값으로 주면 복잡한 수학적 계산을 통해 각종 성능지표인 CPU의 처리량, 프로세스의 평균 대기시간 등을 구하게 됨.
* 구현 및 실측은 구현가들이 수행할 수 있는 방식으로, 운영체제의 커널의 소스 코드 중 CPU 스케줄링을  수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설피하는 과정을 필요로 함. 그런 다음 동일한 프로그램을 원래 커널과 CPU 스케줄러를 수정한 커널에서 수행시켜보고 실행시간을 측정하여 알고리즘의 성능을 평가함.
* 시물레이션은 실제 시스템에 구현해 수행시켜보는 것이 아니라 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지를 확인하는 방법. 입력값은 가상으로 생성할 수도 있고 실제 시스템에서의 CPU 요청 내역을 추출해 사용할 수도 있음. 이때 실제 시스템에서 추출한 입력값을 트레이스(trace)라고 부름. 트레이스는 몇 초에 어떤 프로세스가 도착하고, 각각 CPU 버스트 시간을 얼마로 하는지에 대한 정보를 시간 순서대로 적어놓은 파일을 말함.