# 6장 CPU 스케줄링

* CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙 처리장치
* 프로그램이 시작되어 메모리에 올라가면 프로그램 카운터라는 이름의 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 가지고 있게 됨. CPU는 프로그램 카운터가 가리키는 주소의 기계어 명령을 하나씩 수행함.
* CPU는 일반적으로 한 시스템 내에 하나씩밖에 없으므로 여러 프로그램이 동시에 수행되는 시분할 환경에서 매우 효율적으로 관리되어야 함.

## 프로그램 실행과 관련된 몇가지 기계어 명령
* CPU 내에서 수행되는 명령
	* Add 명령 : CPU내의 레지스터에 있는 두 값을 더해 레지스터에 저장. CPU 내에서만 수행되므로 명령의 수행 속도가 매우 빠름 
* 메모리 접근을 필요로 하는 명령
	* Load/Store 명령 : 메모리에 있는 데이터를 CPU로 / CPU에서 계산된 결과값을 메모리에 저장. 메모리에 접근하는 명령은 비록 CPU 내에서 수행되는 명령보다는 시간이 오래 소요되지만 비교적 짧은 시간에 수행할 수 있는 명령에 해당됨. 또한 CPU 내에서 일어나는 명령이나 메모리를 접근하는 명령은 사용자 프로그램이 직접 실행할 수 있는 일반명령에 해당.
* 입출력을 동반하는 명령
	* 키보드로부터 입력, 컴퓨터에서 처리된 결과를 화면에 출력, 디스크에서 파일 데이터를 읽어오거나 디스크에 파일 형태로 저장하는 것. CPU나 메모리 접근 명령에 비해 오랜 시간이 걸림. 또한 모든 입출력 명령을 특권명령으로 규정해 운영체제를 통해 서비스를 대행하도록 하고 있음.

![](/home/jaehyung/6장_CPU스케줄링/6-1.png)

사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O 작업의 반복으로 구성됨.
* CPU 버스트 : 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계. 프로그램이 I/O를 한 번 수행한 후 다음 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업.
* I/O 버스트 : I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계. I/O 작업이 요청된 후 완료되어 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업.

### 위와 같은 기준에서 프로세스를 나눌수 있음
* CPU 바운드 프로세스: I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스를 말함. 프로세스 수행의 상당 시간을 입출력 작업없이 CPU 작업에 소모하는 계산 위주의 프로그램에 해당. 소수의 긴 CPU 버스트로 구성됨
* I/O 바운드 프로세스: I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스를 말함. 주로 사용자로부터 인터랙션(interaction)을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램이 해당됨. 짧은 CPU 버스트를 많이 가지고 있음.

CPU 스케줄링은 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요한 것.

 ![](/home/jaehyung/6장_CPU스케줄링/6-2.png)

컴퓨터 시스템 내에서 수행되는 프로세스들의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지고 극히 일부분만 긴 CPU 버스트를 가짐. 즉 I/O 작업을 수행한는 프로세스들이 많다. 이러한 대화형 작업은 사용자와 인터랙션을 해가며 프로그램을 수행시킴. 즉 사용자에게서 입력을 받아 CPU 연산을 수행하고 그 결과를 다시 출력하는 작업을 수행. 따라서 빠른 응답이 중요!! (CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요 자세한 이유는 뒤에서~)

## 1. CPU 스케줄러
CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드. 프로세스가 CPU를 할당받고 기계어 명령을 수행하다가 타이머 인터럽트가 발생하면 CPU 스케줄러가 호출됨. 그러면 CPU 스케줄러는 준비 큐에서 CPU를 기다리는 프로세스 중 하나를 선택해 CPU를 할당하게 됨. 이 밖에도 CPU 스케줄링이 필요한 경우들이 몇가지 있음.
스케줄링 방식에 따라
* 비선점형(nonpreemptive) : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법. ex) 실행상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄(blocked)상태로 바뀌는 경우, CPU에서 실행 상태에 있는 프로세스가 종료되는 경우
*  선점형(preemptive) : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법. ex) 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우, I/O 요청으로 봉쇄 상태에 있던 프로세스가 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비상태로 바뀌는 경우(이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아, 인터럽트 처리 후 직전에 수행되던 프로세스에게 CPU를 다시 할당하는 것이 아니라 문맥교환을 통해 I/O가 완료된 프로세스에게 CPU를 할당하는 경우가 해당됨)

## 2. 디스패처
CPU 스케줄러가 어떤 프로세스에게 CPU를 할당해야 할지 결정하고나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요. 이와같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 디스패처(dispatcher)라고 함.
* 디스패처: 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행.

새로운 프로세스의 문맥을 복원시킨 후에는 시스템의 상태를 사용자모드로 전환해 사용자 프로그램에게 CPU의 제어권을 넘기게 됨. 사용자 프로그램은 PC로부터 현재 수행할 주소를 찾게 됨.

* 디스패치 지연시간: 디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간 (대부분은 문맥교환 오버헤드에 해당됨)

## 3. 스케줄링의 성능 평가
스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용되는데 이 지표들은 크게 시스템 관점의 지표와 사용자 관점의 지표로 나누어 볼 수 있음.
* 시스템 관점: CPU 이용률, 처리량
	* CPU 이용률(CPU utilization)은 전체 시간 중에서 CPU가 일을 한 시간의 비율을 나타냄. CPU는 대부분의 시스템에 하나만 존재하는 고비용의 자원이므로 CPU의 이용률은 시스템 전체의 성능과 밀접하게 관련됨. 따라서 CPU가 일을 하지 않고 휴면(idle) 상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표가 됨.
	* 처리량(throughput)은 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스의 개수)를 나타냄. 즉 CPU의 서비스를 원하는 프로세스 중 몇 개가 원하는 만큼의 CPU를 사용하고 이번 CPU 버스트를 끝내어 준비 큐를 떠났는지 측정하는 것이 처리량의 개념. 여러 프로세스가 CPU를 기다리고 있는 상황에서 주어진 시간에 더 많은 프로세스들이 CPU 작업을 완료하기 위해서는 CPU버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리. 
* 사용자 관점: 소요시간, 대기시간, 응답시간 등 기다린 시간과 관련된 지표들이 있음.
	* 소요시간(turnaround time)은 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간, 즉 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합. 해당 CPU 버스트가 완료될 때까지 걸리는 시간으로 프로그램이 시작해서 종료하는 데까지 걸리는 시간이 아님! (에를들어 CPU르 사용하다가 I/O 연산을 위해 CPU를 자진 반납했다면 CPU를 사용하기 위해 준비 큐에 들어왔을 때부터 CPU를 자진 반납하기까지 걸린 시간이 소요시간이 됨.)
	* 대기시간(waiting time)은 CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합. 시분할 시스템에서는 일반적으로 타이머를 사용해서 CPU를 연속적으로 사용할수 있는 시간을 제한함. 따라서 한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러번 발생할 수 있음. 이때 대기시간이란 이번 CPU 버스트가 끝나기까지 준비 큐에서 기다린 시간의 합을 뜻하게 됨.
	* 응답시간(response time)은 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간을 뜻함. 타이머 인터럽트가 빈번히 발생할수록 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 짧아지므로 처음 CPU를 얻기까지 걸리는 시간은 줄어들게 되어 응답시간이 향상됨. 대화형 시스템에 적합한 성능 척도.

## 4. 스케줄링 알고리즘

### 1) 선입선출 스케줄링
* 선입선출(First-Come First-Served FCFS) 스케줄링은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말함.

* 일상생활에서도 흔히 볼 수 있듯이 먼저 온 요청을 먼저 처리하기 때문에 합리적인 것처럼 보임.

* 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라짐.

  ![](/home/jaehyung/6장_CPU스케줄링/6-3.png)

  ![](/home/jaehyung/6장_CPU스케줄링/6-4.png)

* 대기시간: P1 = 0, P2 = 12, P3 = 15

* 평균 대기시간: (0+12+15)/3 = 9

  ![](/home/jaehyung/6장_CPU스케줄링/6-5.png)

* 대기시간: P1 = 6, P2 = 0, P3 = 3

* 평균 대기시간: (6+0+3)/3 = 3

* 전자의 경우처럼 CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 convoy effect라고 하며 FCFS 스케줄링의 대표적인 단점에 해당.

### 2) 최단작업 우선 스케줄링
* 최단작업 우선(Shortest-Job First SJF) 스케줄링 알고리즘은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식.

* CPU 버스트가 짧은 프로세스가 CPU를 먼저 사용하고 준비 큐를 빠져나가게 되면 전체적인 대기시간이 줄어들게 됨.

* SJF 스케줄링 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘

* 비선점형(nonpreemptive) 방식과 선점형(preemptive) 방식이 있음

* 비선점형: CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식을 말함.

* 선점형: 준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했다 하더라도, CPU 버스트가 더 짧은 프로세스가 도착했을 경우 CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식. 현재 실행중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 프로세스가 도착할 경우 CPU를 빼앗음. 따라서 SRTF(Shortest Remaining Time First)라고도 함.

* 프로세스들이 준비 큐에 도착하는 시간이 불규칙하면 선점형 방식이 평균 대기시간을 최소화하는 최적의 알고리즘이 되고 그렇지 않으면 큰 차이 없음. 일반적인 시분할 환경에서는 선점형이 유리.

* SJF

  ![](/home/jaehyung/6장_CPU스케줄링/6-6.png)

  

  ![](/home/jaehyung/6장_CPU스케줄링/6-7.png)

* 평균 대기시간: (0+12+6+14) / 4 = 8

* SRTF

  ![](/home/jaehyung/6장_CPU스케줄링/6-8.png)

* 평균 대기시간: (18+2+0+4) / 4 = 6

* 그러나 SJF 스케줄링 기법의 구현에서 현실적으로 어려운 부분은 프로세스의 CPU 버스트 시간을 미리 알 수 없다는 점. 그래서 예측을 통해 CPU 버스트 시간을 구함.

* CPU 버스트 시간의 예측은 과거의 CPU 버스트 시간을 통해 이루어짐

* (n+1)번째 CPU 버스트의 예측시간 
  $$
  T_{n+1}=at_n+(1-a)T_n
  $$
  
* tn과 Tn은 각각 n번째 실제 CPU 버스트 시간과 n번째 CPU 버스트의 예측시간을 뜻하며, a는 0과 1사이의 상수로 두 요소를 어느 정도 씩 반영할지 조절하는 매개변수.

* a=0 이면 고정된 값이 예측값으로 계속 사용이 되고 a=1이면 바로 전에 사용한 CPU 버스트 시간을 예측값으로 사용하게 됨.

* 즉 과거의 CPU 버스트 시간들을 통해 미래의 CPU 버스트 시간을 예측하게 되고 최근의 CPU 버스트 시간일수록 오래전의 CPU 버스트 시간에 비해 가중치를 높이는 방식

* $$
  T_{n+1}=at_n+(1-a)at_{n-1}+...+(1-a)^jat_{n-j}+...
  $$

* SJF 알고리즘이 평균 대기시간을 최소화하는 알고리즘이기는 하지만 시스템에서 평균을 줄이는 것이 항상 좋은 방법이라고는 할 수 없음. CPU가 버스트가 짧은 프로세스에게만 CPU를 할당할 경우 CPU 버스트가 긴 프로세스는 무한정 기다려야 하기 때문.

* 이러한 현상을 기아현상(Starvation)이라고 하고 극복하는 방법은 뒤에서 설명.

### 3) 우선순위 스케줄링
* 우선순위 스케줄링(Priority Scheduling)이란 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말함.
* 우선순위는 우선순위값(Prioriry Number)을 통해 표시하고 우선순위값이 작을수록 높은 우선순위를 가짐.
* 우선순위를 결정하는 방식에는 CPU 버스트 시간을 우선순위값을 정의하면 SJF와 동일하게 되고 시스템과 관련된 중요한 작업을 수행하는 프로세스의 우선순위를 높게 부여할수도 있음.
* 비선점형과 선점형 방식으로 구현 가능
* 비선점형은 일단 CPU를 얻었으면 자진 반납하기 전까지 선점하지 않음.
* 선점형은 현재 CPU에서 수행 중인 프로세스보다 우선순위가 높은 프로세스가 도착하여 CPU를 선점하는 방식.
* 문제점은 기아 현상이 발생할 수 있음. (우선순위가 높은 프로세스가 계속해서 도착하면 우선순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다려야 함)
* 이러한 문제점을 해결하기 위해서 노화(Aging) 기법을 사용.
* 기다리는 시간이 길어지면 우선순위를 조금씩 높여 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받을 수 있게 하는 방법.